# Computer Science

## Default
Big O notation: how complexity related to the input size
<!-- Memory/Addressing:  -->
<!-- Reading/Insertion/Deletion -->

NP Problem: the problem can be verified (but cannot be solved) in polynomial time.
<!-- https://en.wikipedia.org/wiki/P_versus_NP_problem#NP-completeness -->
<!-- https://en.wikipedia.org/wiki/NP-completeness -->

Recursion vs Iteration:
a function calls itself;
repetition of a process.

Pointer vs Reference:
a variable that holds memory address of another variable;
an alias for an already existing variable.
<!-- https://www.geeksforgeeks.org/pointers-vs-references-cpp/ -->

"passed by reference" vs "passed by value": if the caller and the callee use the same variable
<!-- https://stackoverflow.com/questions/373419/whats-the-difference-between-passing-by-reference-vs-passing-by-value -->

<!-- multithreading -->

## Data structure
<!-- Different forms of restrictions -->
* Array
* Stack
* Queue
* Hash
* Linked List
* Trees
  * binary tree: each node has at most two children.
  * binary search trees (BST): ordered or sorted binary trees.
* Graph
* Heap


## Algorithms

### Searching Problem
* Binary search
* Breadth-first search
* Dijkstraâ€™s algorithm

### Sorting Problem
* Selection sort
* Quick sort -> Divide & conquer
* Merge sort

<!-- ### Box Problem
* Recursion -->

### NP-complete problems
* The classroom scheduling problem
* The knapsack problem
* The set-covering problem
* The traveling salesperson
* Greedy algorithm
* Dynamic programming

<!-- ### Classification Problem:
k-nearest neighbors -->

## Object-Oriented Programming

### Default

Overriding: replace a method from superclass; run-time polymorphism (Dynamic polymorphism?)
Overloading: compile-time polymorphism (Static polymorphism?)

Interfaces: represent a capability
Abstract Class: represent a type
<!-- concrete class -->

Inheritance vs Aggregation vs Composition: "is a" / "has a" (a collection of objects) / "owns a"

<!-- Virtual function:  -->



### Principles

* Encapsulation: keep object's state private
* Abstraction: hide internal implementation details
* Inheritance: reuse the parent's logics
* Polymorphism: use a single interface to different types
